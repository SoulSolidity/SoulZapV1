/* NOTE: This file was generated by the test-generation scripts. */

/**
 * hardhat-network-helpers:
 * `mine`: Increase block height
 * `time`: Adjust block timestamp
 */
import { mine, time, loadFixture } from '@nomicfoundation/hardhat-network-helpers'
// TODO: Add a fixture for this contract or remove
import { fixture } from './SoulZap_UniV2.spec'
/**
 * hardhat-chai-matchers reference
 * https://hardhat.org/hardhat-chai-matchers/docs/reference
 *
 * The @nomicfoundation/hardhat-chai-matchers plugin is meant to be a drop-in replacement
 * for the @nomiclabs/hardhat-waffle plugin
 *
 * https://hardhat.org/hardhat-chai-matchers/docs/migrate-from-waffle
 *
 * VSCode + Hardhat:
 * https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity
 */
import { anyValue } from '@nomicfoundation/hardhat-chai-matchers/withArgs'
import { expect } from 'chai'
import { ethers } from 'hardhat'
import { ADDRESS_ZERO, ether } from './utils'
import { NATIVE_ADDRESS } from '../src'

describe('SoulZap_UniV2', function () {
  // NOTE: Reusing fixture from soulZap.spec.ts
  // async function fixture() {
  //   const lockDeployment = await deployFixture(ethers)
  //   return { ...lockDeployment }
  // }
  describe('constructor', function () {
    it('Should valid parameters', async function () {
      const {
        dexAndHopTokens_deployment: {
          uniV2Dex: { mockWBNB },
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens, soulFeeManager },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const SoulZap = await ethers.getContractFactory('SoulZap_UniV2')
      const newSoulZap = SoulZap.deploy(owner.address, mockWBNB.address, soulFeeManager.address, 0)
      expect(newSoulZap).to.exist
    })

    it('Should fail when invalid soulFeeManager', async function () {
      const {
        dexAndHopTokens_deployment: {
          uniV2Dex: { mockWBNB },
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const SoulZap = await ethers.getContractFactory('SoulZap_UniV2')
      await expect(SoulZap.deploy(owner.address, mockWBNB.address, ADDRESS_ZERO, 0)).to.be.reverted
      // NOTE: Not able to get the revertedWith working
      // await expect(SoulZap.deploy(owner.address, mockWBNB.address, ADDRESS_ZERO, 0)).to.be.revertedWith(
      //   'SoulZap: soulFeeManager is not ISoulFeeManager'
      // )
    })
  })

  describe('receive', function () {
    /*
    // FIXME: cc
    it('Should receive ETH from WNATIVE', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap.receive()
      expect(result).to.exist
    })
    */
    it('Should fail when receive ETH from non-WNATIVE', async function () {
      const {
        dexAndHopTokens_deployment: {
          uniV2Dex: { mockWBNB },
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      // transfer BNB to soulZap and expect revert
      await expect(
        owner.sendTransaction({
          to: soulZap.address,
          value: ethers.utils.parseEther('1'),
        })
      ).to.be.revertedWith('SoulZap: Only receive from WNATIVE')
    })
  })
  describe('verifyMsgValueAndWrap', function () {
    it('Should pass msg.value > 0 and inputToken is NATIVE_ADDRESS', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const zapData = await soulZap_Lens.getZapData(
        NATIVE_ADDRESS,
        ether('1'),
        pairs.hopLpPairs[0].address,
        300,
        zapReceiver.address
      )

      await soulZap.zap(zapData.zapParams, zapData.feeSwapPath, { value: ether('1') })
    })

    it('Should fail when msg.value > 0 and inputToken is not NATIVE_ADDRESS', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      // NOTE: 1 Ether hardcoded
      const currentInputAmount = ether('1')
      const currentInputToken = inputTokens[0]
      await currentInputToken.connect(tokensOwner).approve(soulZap.address, currentInputAmount)

      const zapData = await soulZap_Lens.getZapData(
        currentInputToken.address,
        ether('1'),
        pairs.hopLpPairs[0].address,
        300,
        zapReceiver.address
      )

      await expect(
        soulZap.connect(tokensOwner).zap(zapData.zapParams, zapData.feeSwapPath, { value: ether('1') })
      ).to.be.revertedWith('SoulZap: inputToken MUST be NATIVE_ADDRESS with msg.value')
    })
    it('Should pass when msg.value is 0', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      // NOTE: 1 Ether hardcoded
      const currentInputAmount = ether('1')
      const currentInputToken = inputTokens[0]
      await currentInputToken.connect(tokensOwner).approve(soulZap.address, currentInputAmount)

      const zapData = await soulZap_Lens.getZapData(
        currentInputToken.address,
        ether('1'),
        pairs.hopLpPairs[0].address,
        300,
        zapReceiver.address
      )

      await soulZap.connect(tokensOwner).zap(zapData.zapParams, zapData.feeSwapPath)
    })
  })

  describe('pause/unpause', function () {
    it('Should pause by authorized user', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await soulZap.connect(owner).pause()
    })
    it('Should unpause by authorized user', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await soulZap.connect(owner).pause()
      await soulZap.connect(owner).unpause()
    })
    it('Should fail when pause by unauthorized user', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.connect(zapReceiver).pause()).to.be.revertedWithCustomError(
        soulZap,
        'AccessManagedUnauthorized'
      )
    })
    it('Should fail when unpause by unauthorized user', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await soulZap.connect(owner).pause()
      await expect(soulZap.connect(zapReceiver).pause()).to.be.revertedWithCustomError(
        soulZap,
        'AccessManagedUnauthorized'
      )
    })
  })

  describe('swap', function () {
    it('Should swap with valid parameters', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await takeERC20BalanceSnapshot()

      // NOTE: 1 Ether hardcoded
      const currentInputAmount = ether('1')
      const currentInputToken = inputTokens[0]
      await currentInputToken.connect(tokensOwner).approve(soulZap.address, currentInputAmount)
      const currentToToken = inputTokens[1]

      const swapData = await soulZap_Lens.getSwapData(
        currentInputToken.address,
        currentInputAmount,
        currentToToken.address,
        300,
        zapReceiver.address
      )

      await soulZap.connect(tokensOwner).swap(swapData.swapParams, swapData.feeSwapPath)

      const balanceSnapshot = await takeERC20BalanceSnapshot()

      expect(balanceSnapshot[zapReceiver.address][currentToToken.address].balanceDiff).to.be.greaterThan(0)
      expect(balanceSnapshot[tokensOwner.address][currentInputToken.address].balanceDiff).to.be.lessThan(0)
    })
    /*
    // TODO: Swap tests
    it('Should fail when swap with invalid inputToken', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.swap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when swap with insufficient inputAmount', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.swap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when swap to null address', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.swap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when swap with same input and output token', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.swap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when swap with paused contract', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.swap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    */
  })

  /*
    // TODO: To implement:
  describe('zap', function () {
    it('Should zap with valid parameters', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap.zap()
      expect(result).to.exist

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when zap with invalid inputToken', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.zap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when zap with insufficient inputAmount', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.zap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when zap to null address', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.zap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when zap with unsupported LPType', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.zap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when zap with paused contract', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.zap()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
  })

  describe('isFeeToken', function () {
    it('Should check valid fee token', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap.isFeeToken()
      expect(result).to.exist

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when check invalid fee token', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap.isFeeToken()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
  })
  describe('getFeeInfo', function () {
    it('Should retrieve fee info with valid epoch volume', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap.getFeeInfo()
      expect(result).to.exist

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
  })
  describe('_handleFee', function () {
    it('Should handle fee with non-zero fee percentage', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap._handleFee()
      expect(result).to.exist

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should handle fee with zero fee percentage', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      const result = await soulZap._handleFee()
      expect(result).to.exist

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
    it('Should fail when handle fee with invalid output token in feeSwapPath', async function () {
      const {
        dexAndHopTokens_deployment: {
          baseTokens: { inputTokens },
          pairs,
        },
        ZapUniV2_Extended_V1_deployment: { soulZap, soulZap_Lens },
        accounts: [owner, feeTo, tokensOwner, zapReceiver],
        snapshotters: { takeERC20BalanceSnapshot, takeFeeSnapshot },
      } = await loadFixture(fixture)

      await expect(soulZap._handleFee()).to.be.reverted

      // NOTE: test generated by test-generation
      expect(true).to.equal(false, 'TODO: Test not reviewed for correctness.')
    })
  })
  */
})
